'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var zodToJsonSchema = require('zod-to-json-schema');
var child_process = require('child_process');
var stream = require('stream');
var backendCommon = require('@backstage/backend-common');
var errors = require('@backstage/errors');
var fs = require('fs-extra');
var path = require('path');
var backendPluginApi = require('@backstage/backend-plugin-api');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var zodToJsonSchema__default = /*#__PURE__*/_interopDefaultLegacy(zodToJsonSchema);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);

const createTemplateAction = (action) => {
  var _a, _b, _c, _d;
  const inputSchema = ((_a = action.schema) == null ? void 0 : _a.input) && "safeParseAsync" in action.schema.input ? zodToJsonSchema__default["default"](action.schema.input) : (_b = action.schema) == null ? void 0 : _b.input;
  const outputSchema = ((_c = action.schema) == null ? void 0 : _c.output) && "safeParseAsync" in action.schema.output ? zodToJsonSchema__default["default"](action.schema.output) : (_d = action.schema) == null ? void 0 : _d.output;
  return {
    ...action,
    schema: {
      ...action.schema,
      input: inputSchema,
      output: outputSchema
    }
  };
};

async function executeShellCommand(options) {
  const {
    command,
    args,
    options: spawnOptions,
    logStream = new stream.PassThrough()
  } = options;
  await new Promise((resolve, reject) => {
    const process = child_process.spawn(command, args, spawnOptions);
    process.stdout.on("data", (stream) => {
      logStream.write(stream);
    });
    process.stderr.on("data", (stream) => {
      logStream.write(stream);
    });
    process.on("error", (error) => {
      return reject(error);
    });
    process.on("close", (code) => {
      if (code !== 0) {
        return reject(
          new Error(`Command ${command} failed, exit code: ${code}`)
        );
      }
      return resolve();
    });
  });
}

async function fetchContents(options) {
  const { reader, integrations, baseUrl, fetchUrl = ".", outputPath } = options;
  const fetchUrlIsAbsolute = isFetchUrlAbsolute(fetchUrl);
  if (!fetchUrlIsAbsolute && (baseUrl == null ? void 0 : baseUrl.startsWith("file://"))) {
    const basePath = baseUrl.slice("file://".length);
    const srcDir = backendCommon.resolveSafeChildPath(path__default["default"].dirname(basePath), fetchUrl);
    await fs__default["default"].copy(srcDir, outputPath);
  } else {
    const readUrl = getReadUrl(fetchUrl, baseUrl, integrations);
    const res = await reader.readTree(readUrl);
    await fs__default["default"].ensureDir(outputPath);
    await res.dir({ targetDir: outputPath });
  }
}
async function fetchFile(options) {
  const { reader, integrations, baseUrl, fetchUrl = ".", outputPath } = options;
  const fetchUrlIsAbsolute = isFetchUrlAbsolute(fetchUrl);
  if (!fetchUrlIsAbsolute && (baseUrl == null ? void 0 : baseUrl.startsWith("file://"))) {
    const basePath = baseUrl.slice("file://".length);
    const src = backendCommon.resolveSafeChildPath(path__default["default"].dirname(basePath), fetchUrl);
    await fs__default["default"].copyFile(src, outputPath);
  } else {
    const readUrl = getReadUrl(fetchUrl, baseUrl, integrations);
    const res = await reader.readUrl(readUrl);
    await fs__default["default"].ensureDir(path__default["default"].dirname(outputPath));
    const buffer = await res.buffer();
    await fs__default["default"].outputFile(outputPath, buffer.toString());
  }
}
function isFetchUrlAbsolute(fetchUrl) {
  let fetchUrlIsAbsolute = false;
  try {
    new URL(fetchUrl);
    fetchUrlIsAbsolute = true;
  } catch {
  }
  return fetchUrlIsAbsolute;
}
function getReadUrl(fetchUrl, baseUrl, integrations) {
  if (isFetchUrlAbsolute(fetchUrl)) {
    return fetchUrl;
  } else if (baseUrl) {
    const integration = integrations.byUrl(baseUrl);
    if (!integration) {
      throw new errors.InputError(`No integration found for location ${baseUrl}`);
    }
    return integration.resolveUrl({
      url: fetchUrl,
      base: baseUrl
    });
  }
  throw new errors.InputError(
    `Failed to fetch, template location could not be determined and the fetch URL is relative, ${fetchUrl}`
  );
}

const scaffolderActionsExtensionPoint = backendPluginApi.createExtensionPoint({
  id: "scaffolder.actions"
});
const scaffolderTaskBrokerExtensionPoint = backendPluginApi.createExtensionPoint({
  id: "scaffolder.taskBroker"
});
const scaffolderTemplatingExtensionPoint = backendPluginApi.createExtensionPoint({
  id: "scaffolder.templating"
});

exports.createTemplateAction = createTemplateAction;
exports.executeShellCommand = executeShellCommand;
exports.fetchContents = fetchContents;
exports.fetchFile = fetchFile;
exports.scaffolderActionsExtensionPoint = scaffolderActionsExtensionPoint;
exports.scaffolderTaskBrokerExtensionPoint = scaffolderTaskBrokerExtensionPoint;
exports.scaffolderTemplatingExtensionPoint = scaffolderTemplatingExtensionPoint;
//# sourceMappingURL=index.cjs.js.map
