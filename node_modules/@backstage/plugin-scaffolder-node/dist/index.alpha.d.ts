/**
 * The scaffolder-node module for `@backstage/plugin-scaffolder-backend`.
 *
 * @packageDocumentation
 */

/// <reference types="node" />

import { ExtensionPoint } from '@backstage/backend-plugin-api';
import { JsonObject } from '@backstage/types';
import { JsonValue } from '@backstage/types';
import { Logger } from 'winston';
import { Observable } from '@backstage/types';
import { Schema } from 'jsonschema';
import { ScmIntegrations } from '@backstage/integration';
import { SpawnOptionsWithoutStdio } from 'child_process';
import { TaskBroker as TaskBroker_2 } from '@backstage/plugin-scaffolder-node';
import { TaskSpec } from '@backstage/plugin-scaffolder-common';
import { TemplateAction as TemplateAction_2 } from '@backstage/plugin-scaffolder-node';
import { TemplateFilter as TemplateFilter_2 } from '@backstage/plugin-scaffolder-node';
import { TemplateGlobal as TemplateGlobal_2 } from '@backstage/plugin-scaffolder-node';
import { TemplateInfo } from '@backstage/plugin-scaffolder-common';
import { UrlReader } from '@backstage/backend-common';
import { UserEntity } from '@backstage/catalog-model';
import { Writable } from 'stream';
import { z } from 'zod';

/**
 * ActionContext is passed into scaffolder actions.
 * @public
 */
export declare type ActionContext<TActionInput extends JsonObject, TActionOutput extends JsonObject = JsonObject> = {
    logger: Logger;
    logStream: Writable;
    secrets?: TaskSecrets;
    workspacePath: string;
    input: TActionInput;
    output(name: keyof TActionOutput, value: TActionOutput[keyof TActionOutput]): void;
    /**
     * Creates a temporary directory for use by the action, which is then cleaned up automatically.
     */
    createTemporaryDirectory(): Promise<string>;
    templateInfo?: TemplateInfo;
    /**
     * Whether this action invocation is a dry-run or not.
     * This will only ever be true if the actions as marked as supporting dry-runs.
     */
    isDryRun?: boolean;
    /**
     * The user which triggered the action.
     */
    user?: {
        /**
         * The decorated entity from the Catalog
         */
        entity?: UserEntity;
        /**
         * An entity ref for the author of the task
         */
        ref?: string;
    };
    /**
     * Implement the signal to make your custom step abortable https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal
     */
    signal?: AbortSignal;
    /**
     * Optional value of each invocation
     */
    each?: JsonObject;
};

/**
 * This function is used to create new template actions to get type safety.
 * Will convert zod schemas to json schemas for use throughout the system.
 * @public
 */
export declare const createTemplateAction: <TInputParams extends JsonObject = JsonObject, TOutputParams extends JsonObject = JsonObject, TInputSchema extends z.ZodType<any, z.ZodTypeDef, any> | Schema = {}, TOutputSchema extends z.ZodType<any, z.ZodTypeDef, any> | Schema = {}, TActionInput extends JsonObject = TInputSchema extends z.ZodType<any, any, infer IReturn> ? IReturn : TInputParams, TActionOutput extends JsonObject = TOutputSchema extends z.ZodType<any, any, infer IReturn_1> ? IReturn_1 : TOutputParams>(action: TemplateActionOptions<TActionInput, TActionOutput, TInputSchema, TOutputSchema>) => TemplateAction<TActionInput, TActionOutput>;

/**
 * Run a command in a sub-process, normally a shell command.
 *
 * @public
 */
export declare function executeShellCommand(options: ExecuteShellCommandOptions): Promise<void>;

/**
 * Options for {@link executeShellCommand}.
 *
 * @public
 */
export declare type ExecuteShellCommandOptions = {
    /** command to run */
    command: string;
    /** arguments to pass the command */
    args: string[];
    /** options to pass to spawn */
    options?: SpawnOptionsWithoutStdio;
    /** stream to capture stdout and stderr output */
    logStream?: Writable;
};

/**
 * A helper function that reads the contents of a directory from the given URL.
 * Can be used in your own actions, and also used behind fetch:template and fetch:plain
 *
 * @public
 */
export declare function fetchContents(options: {
    reader: UrlReader;
    integrations: ScmIntegrations;
    baseUrl?: string;
    fetchUrl?: string;
    outputPath: string;
}): Promise<void>;

/**
 * A helper function that reads the content of a single file from the given URL.
 * Can be used in your own actions, and also used behind `fetch:plain:file`
 *
 * @public
 */
export declare function fetchFile(options: {
    reader: UrlReader;
    integrations: ScmIntegrations;
    baseUrl?: string;
    fetchUrl?: string;
    outputPath: string;
}): Promise<void>;

/**
 * Extension point for managing scaffolder actions.
 *
 * @alpha
 */
export declare interface ScaffolderActionsExtensionPoint {
    addActions(...actions: TemplateAction_2<any, any>[]): void;
}

/**
 * Extension point for managing scaffolder actions.
 *
 * @alpha
 */
export declare const scaffolderActionsExtensionPoint: ExtensionPoint<ScaffolderActionsExtensionPoint>;

/**
 * Extension point for replacing the scaffolder task broker.
 *
 * @alpha
 */
export declare interface ScaffolderTaskBrokerExtensionPoint {
    setTaskBroker(taskBroker: TaskBroker_2): void;
}

/**
 * Extension point for replacing the scaffolder task broker.
 *
 * @alpha
 */
export declare const scaffolderTaskBrokerExtensionPoint: ExtensionPoint<ScaffolderTaskBrokerExtensionPoint>;

/**
 * Extension point for adding template filters and globals.
 *
 * @alpha
 */
export declare interface ScaffolderTemplatingExtensionPoint {
    addTemplateFilters(filters: Record<string, TemplateFilter_2>): void;
    addTemplateGlobals(filters: Record<string, TemplateGlobal_2>): void;
}

/**
 * Extension point for adding template filters and globals.
 *
 * @alpha
 */
export declare const scaffolderTemplatingExtensionPoint: ExtensionPoint<ScaffolderTemplatingExtensionPoint>;

/**
 * SerializedTask
 *
 * @public
 */
export declare type SerializedTask = {
    id: string;
    spec: TaskSpec;
    status: TaskStatus;
    createdAt: string;
    lastHeartbeatAt?: string;
    createdBy?: string;
    secrets?: TaskSecrets;
};

/**
 * SerializedTaskEvent
 *
 * @public
 */
export declare type SerializedTaskEvent = {
    id: number;
    taskId: string;
    body: JsonObject;
    type: TaskEventType;
    createdAt: string;
};

/**
 * TaskBroker
 *
 * @public
 */
export declare interface TaskBroker {
    cancel?(taskId: string): Promise<void>;
    claim(): Promise<TaskContext>;
    dispatch(options: TaskBrokerDispatchOptions): Promise<TaskBrokerDispatchResult>;
    vacuumTasks(options: {
        timeoutS: number;
    }): Promise<void>;
    event$(options: {
        taskId: string;
        after: number | undefined;
    }): Observable<{
        events: SerializedTaskEvent[];
    }>;
    get(taskId: string): Promise<SerializedTask>;
    list?(options?: {
        createdBy?: string;
    }): Promise<{
        tasks: SerializedTask[];
    }>;
}

/**
 * The options passed to {@link TaskBroker.dispatch}
 * Currently a spec and optional secrets
 *
 * @public
 */
export declare type TaskBrokerDispatchOptions = {
    spec: TaskSpec;
    secrets?: TaskSecrets;
    createdBy?: string;
};

/**
 * The result of {@link TaskBroker.dispatch}
 *
 * @public
 */
export declare type TaskBrokerDispatchResult = {
    taskId: string;
};

/**
 * The state of a completed task.
 *
 * @public
 */
export declare type TaskCompletionState = 'failed' | 'completed';

/**
 * Task
 *
 * @public
 */
export declare interface TaskContext {
    cancelSignal: AbortSignal;
    spec: TaskSpec;
    secrets?: TaskSecrets;
    createdBy?: string;
    done: boolean;
    isDryRun?: boolean;
    complete(result: TaskCompletionState, metadata?: JsonObject): Promise<void>;
    emitLog(message: string, logMetadata?: JsonObject): Promise<void>;
    getWorkspaceName(): Promise<string>;
}

/**
 * TaskEventType
 *
 * @public
 */
export declare type TaskEventType = 'completion' | 'log' | 'cancelled';

/**
 * TaskSecrets
 *
 * @public
 */
export declare type TaskSecrets = Record<string, string> & {
    backstageToken?: string;
};

/**
 * The status of each step of the Task
 *
 * @public
 */
export declare type TaskStatus = 'cancelled' | 'completed' | 'failed' | 'open' | 'processing';

/** @public */
export declare type TemplateAction<TActionInput extends JsonObject = JsonObject, TActionOutput extends JsonObject = JsonObject> = {
    id: string;
    description?: string;
    examples?: {
        description: string;
        example: string;
    }[];
    supportsDryRun?: boolean;
    schema?: {
        input?: Schema;
        output?: Schema;
    };
    handler: (ctx: ActionContext<TActionInput, TActionOutput>) => Promise<void>;
};

/** @public */
export declare type TemplateActionOptions<TActionInput extends JsonObject = {}, TActionOutput extends JsonObject = {}, TInputSchema extends Schema | z.ZodType = {}, TOutputSchema extends Schema | z.ZodType = {}> = {
    id: string;
    description?: string;
    examples?: TemplateExample[];
    supportsDryRun?: boolean;
    schema?: {
        input?: TInputSchema;
        output?: TOutputSchema;
    };
    handler: (ctx: ActionContext<TActionInput, TActionOutput>) => Promise<void>;
};

/** @public */
export declare type TemplateExample = {
    description: string;
    example: string;
};

/** @public */
export declare type TemplateFilter = (...args: JsonValue[]) => JsonValue | undefined;

/** @public */
export declare type TemplateGlobal = ((...args: JsonValue[]) => JsonValue | undefined) | JsonValue;

export { }
