'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var backendPluginApi = require('@backstage/backend-plugin-api');
var alpha = require('@backstage/backend-plugin-api/alpha');
var path = require('path');
var fs = require('fs-extra');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);

const LOADED_PACKAGE_ROLES = ["backend-plugin", "backend-module"];
async function findClosestPackageDir(searchDir) {
  let path$1 = searchDir;
  for (let i = 0; i < 1e3; i++) {
    const packagePath = path.resolve(path$1, "package.json");
    const exists = await fs__default["default"].pathExists(packagePath);
    if (exists) {
      return path$1;
    }
    const newPath = path.dirname(path$1);
    if (newPath === path$1) {
      return void 0;
    }
    path$1 = newPath;
  }
  throw new Error(
    `Iteration limit reached when searching for root package.json at ${searchDir}`
  );
}
class PackageDiscoveryService {
  constructor(config) {
    this.config = config;
  }
  async getBackendFeatures() {
    var _a, _b;
    if (this.config.getOptionalString("backend.packages") !== "all") {
      return { features: [] };
    }
    const packageDir = await findClosestPackageDir(process.argv[1]);
    if (!packageDir) {
      throw new Error("Package discovery failed to find package.json");
    }
    const { dependencies } = require(path.resolve(
      packageDir,
      "package.json"
    ));
    const dependencyNames = Object.keys(dependencies || {});
    const features = [];
    for (const name of dependencyNames) {
      const depPkg = require(require.resolve(`${name}/package.json`, {
        paths: [packageDir]
      }));
      if (!LOADED_PACKAGE_ROLES.includes((_b = (_a = depPkg == null ? void 0 : depPkg.backstage) == null ? void 0 : _a.role) != null ? _b : "")) {
        continue;
      }
      const depModule = require(require.resolve(name, { paths: [packageDir] }));
      for (const exportValue of Object.values(depModule)) {
        if (isBackendFeature(exportValue)) {
          features.push(exportValue);
        }
        if (isBackendFeatureFactory(exportValue)) {
          features.push(exportValue());
        }
      }
    }
    return { features };
  }
}
const featureDiscoveryServiceFactory = backendPluginApi.createServiceFactory({
  service: alpha.featureDiscoveryServiceRef,
  deps: {
    config: backendPluginApi.coreServices.rootConfig
  },
  factory({ config }) {
    return new PackageDiscoveryService(config);
  }
});
function isBackendFeature(value) {
  return !!value && typeof value === "object" && value.$$type === "@backstage/BackendFeature";
}
function isBackendFeatureFactory(value) {
  return !!value && typeof value === "function" && value.$$type === "@backstage/BackendFeatureFactory";
}

exports.featureDiscoveryServiceFactory = featureDiscoveryServiceFactory;
//# sourceMappingURL=alpha.cjs.js.map
