import { parseEntityRef } from '@backstage/catalog-model';
import { DismissableBanner, Link, Page, Header, Content, ErrorPage, Progress, LogViewer } from '@backstage/core-components';
import { useApp, useRouteRef, useApi, useRouteRefParams } from '@backstage/core-plugin-api';
import { Box, makeStyles, Grid, Typography, StepButton, Paper, Button, CircularProgress } from '@material-ui/core';
import Grid$1 from '@material-ui/core/Grid';
import Step from '@material-ui/core/Step';
import StepLabel from '@material-ui/core/StepLabel';
import Stepper from '@material-ui/core/Stepper';
import { makeStyles as makeStyles$1, createStyles } from '@material-ui/core/styles';
import Typography$1 from '@material-ui/core/Typography';
import Cancel from '@material-ui/icons/Cancel';
import Check from '@material-ui/icons/Check';
import FiberManualRecordIcon from '@material-ui/icons/FiberManualRecord';
import classNames from 'classnames';
import { DateTime, Interval } from 'luxon';
import qs from 'qs';
import React, { useRef, useEffect, memo, useState, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import useInterval from 'react-use/lib/useInterval';
import { scaffolderApiRef, useTaskEventStream } from '@backstage/plugin-scaffolder-react';
import { entityRouteRef } from '@backstage/plugin-catalog-react';
import LanguageIcon from '@material-ui/icons/Language';
import { r as rootRouteRef, n as selectedTemplateRouteRef, o as scaffolderTaskRouteRef } from './plugin-34a96253.esm.js';

const TaskErrors = ({ error }) => {
  const id = useRef("");
  useEffect(() => {
    id.current = String(Math.random());
  }, [error]);
  return error ? /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(
    DismissableBanner,
    {
      id: id.current,
      variant: "warning",
      message: error.message
    }
  )) : null;
};

const useStyles$1 = makeStyles({
  svgIcon: {
    display: "inline-block",
    "& svg": {
      display: "inline-block",
      fontSize: "inherit",
      verticalAlign: "baseline"
    }
  }
});
const IconLink = (props) => {
  const { href, text, Icon, ...linkProps } = props;
  const classes = useStyles$1();
  return /* @__PURE__ */ React.createElement(Grid, { container: true, direction: "row", spacing: 1 }, /* @__PURE__ */ React.createElement(Grid, { item: true }, /* @__PURE__ */ React.createElement(Typography, { component: "div", className: classes.svgIcon }, Icon ? /* @__PURE__ */ React.createElement(Icon, null) : /* @__PURE__ */ React.createElement(LanguageIcon, null))), /* @__PURE__ */ React.createElement(Grid, { item: true }, /* @__PURE__ */ React.createElement(Link, { to: href, ...linkProps }, text || href)));
};

const TaskPageLinks = ({ output }) => {
  const { links = [] } = output;
  const app = useApp();
  const entityRoute = useRouteRef(entityRouteRef);
  const iconResolver = (key) => {
    var _a;
    return key ? (_a = app.getSystemIcon(key)) != null ? _a : LanguageIcon : LanguageIcon;
  };
  return /* @__PURE__ */ React.createElement(Box, { px: 3, pb: 3 }, links.filter(({ url, entityRef }) => url || entityRef).map(({ url, entityRef, title, icon }) => {
    if (entityRef) {
      const entityName = parseEntityRef(entityRef, {
        defaultKind: "<unknown>",
        defaultNamespace: "<unknown>"
      });
      const target = entityRoute(entityName);
      return { title, icon, url: target };
    }
    return { title, icon, url };
  }).map(({ url, title, icon }, i) => /* @__PURE__ */ React.createElement(
    IconLink,
    {
      key: `output-link-${i}`,
      href: url,
      text: title != null ? title : url,
      Icon: iconResolver(icon),
      target: "_blank"
    }
  )));
};

const humanizeDuration = require("humanize-duration");
const useStyles = makeStyles$1(
  (theme) => createStyles({
    root: {
      width: "100%"
    },
    button: {
      marginBottom: theme.spacing(2),
      marginLeft: theme.spacing(2)
    },
    actionsContainer: {
      marginBottom: theme.spacing(2)
    },
    resetContainer: {
      padding: theme.spacing(3)
    },
    labelWrapper: {
      display: "flex",
      flex: 1,
      flexDirection: "row",
      justifyContent: "space-between"
    },
    stepWrapper: {
      width: "100%"
    }
  })
);
const StepTimeTicker = ({ step }) => {
  const [time, setTime] = useState("");
  useInterval(() => {
    if (!step.startedAt) {
      setTime("");
      return;
    }
    const end = step.endedAt ? DateTime.fromISO(step.endedAt) : DateTime.local();
    const startedAt = DateTime.fromISO(step.startedAt);
    const formatted = Interval.fromDateTimes(startedAt, end).toDuration().valueOf();
    setTime(humanizeDuration(formatted, { round: true }));
  }, 1e3);
  return /* @__PURE__ */ React.createElement(Typography$1, { variant: "caption" }, time);
};
const useStepIconStyles = makeStyles$1(
  (theme) => createStyles({
    root: {
      color: theme.palette.text.disabled,
      display: "flex",
      height: 22,
      alignItems: "center"
    },
    completed: {
      color: theme.palette.status.ok
    },
    error: {
      color: theme.palette.status.error
    }
  })
);
function TaskStepIconComponent(props) {
  const classes = useStepIconStyles();
  const { active, completed, error } = props;
  const getMiddle = () => {
    if (active) {
      return /* @__PURE__ */ React.createElement(CircularProgress, { size: "24px" });
    }
    if (completed) {
      return /* @__PURE__ */ React.createElement(Check, null);
    }
    if (error) {
      return /* @__PURE__ */ React.createElement(Cancel, null);
    }
    return /* @__PURE__ */ React.createElement(FiberManualRecordIcon, null);
  };
  return /* @__PURE__ */ React.createElement(
    "div",
    {
      className: classNames(classes.root, {
        [classes.completed]: completed,
        [classes.error]: error
      })
    },
    getMiddle()
  );
}
const TaskStatusStepper = memo(
  (props) => {
    const { steps, currentStepId, onUserStepChange } = props;
    const classes = useStyles(props);
    return /* @__PURE__ */ React.createElement("div", { className: classes.root }, /* @__PURE__ */ React.createElement(
      Stepper,
      {
        activeStep: steps.findIndex((s) => s.id === currentStepId),
        orientation: "vertical",
        nonLinear: true
      },
      steps.map((step, index) => {
        const isCancelled = step.status === "cancelled";
        const isActive = step.status === "processing";
        const isCompleted = step.status === "completed";
        const isFailed = step.status === "failed";
        const isSkipped = step.status === "skipped";
        return /* @__PURE__ */ React.createElement(Step, { key: String(index), expanded: true }, /* @__PURE__ */ React.createElement(StepButton, { onClick: () => onUserStepChange(step.id) }, /* @__PURE__ */ React.createElement(
          StepLabel,
          {
            StepIconProps: {
              completed: isCompleted,
              error: isFailed || isCancelled,
              active: isActive
            },
            StepIconComponent: TaskStepIconComponent,
            className: classes.stepWrapper
          },
          /* @__PURE__ */ React.createElement("div", { className: classes.labelWrapper }, /* @__PURE__ */ React.createElement(Typography$1, { variant: "subtitle2" }, step.name), isSkipped ? /* @__PURE__ */ React.createElement(Typography$1, { variant: "caption" }, "Skipped") : /* @__PURE__ */ React.createElement(StepTimeTicker, { step }))
        )));
      })
    ));
  }
);
const hasLinks = ({ links = [] }) => links.length > 0;
const TaskPage = (props) => {
  const { loadingText } = props;
  const classes = useStyles();
  const navigate = useNavigate();
  const rootPath = useRouteRef(rootRouteRef);
  const scaffolderApi = useApi(scaffolderApiRef);
  const templateRoute = useRouteRef(selectedTemplateRouteRef);
  const [userSelectedStepId, setUserSelectedStepId] = useState(void 0);
  const [clickedToCancel, setClickedToCancel] = useState(false);
  const [lastActiveStepId, setLastActiveStepId] = useState(
    void 0
  );
  const { taskId } = useRouteRefParams(scaffolderTaskRouteRef);
  const taskStream = useTaskEventStream(taskId);
  const completed = taskStream.completed;
  const taskCancelled = taskStream.cancelled;
  const steps = useMemo(
    () => {
      var _a, _b;
      return (_b = (_a = taskStream.task) == null ? void 0 : _a.spec.steps.map((step) => {
        var _a2;
        return {
          ...step,
          ...(_a2 = taskStream == null ? void 0 : taskStream.steps) == null ? void 0 : _a2[step.id]
        };
      })) != null ? _b : [];
    },
    [taskStream]
  );
  useEffect(() => {
    var _a;
    const mostRecentFailedOrActiveStep = steps.find(
      (step) => ["failed", "processing"].includes(step.status)
    );
    if (completed && !mostRecentFailedOrActiveStep) {
      setLastActiveStepId((_a = steps[steps.length - 1]) == null ? void 0 : _a.id);
      return;
    }
    setLastActiveStepId(mostRecentFailedOrActiveStep == null ? void 0 : mostRecentFailedOrActiveStep.id);
  }, [steps, completed]);
  const currentStepId = userSelectedStepId != null ? userSelectedStepId : lastActiveStepId;
  const logAsString = useMemo(() => {
    if (!currentStepId) {
      return loadingText ? loadingText : "Loading...";
    }
    const log = taskStream.stepLogs[currentStepId];
    if (!(log == null ? void 0 : log.length)) {
      return "Waiting for logs...";
    }
    return log.join("\n");
  }, [taskStream.stepLogs, currentStepId, loadingText]);
  const taskNotFound = taskStream.completed && !taskStream.loading && !taskStream.task;
  const { output } = taskStream;
  const handleStartOver = () => {
    var _a, _b, _c;
    if (!taskStream.task || !((_b = (_a = taskStream.task) == null ? void 0 : _a.spec.templateInfo) == null ? void 0 : _b.entityRef)) {
      navigate(rootPath());
      return;
    }
    const formData = taskStream.task.spec.parameters;
    const { name, namespace } = parseEntityRef(
      (_c = taskStream.task.spec.templateInfo) == null ? void 0 : _c.entityRef
    );
    navigate(
      `${templateRoute({ templateName: name, namespace })}?${qs.stringify({
        formData: JSON.stringify(formData)
      })}`
    );
  };
  const handleCancel = async () => {
    setClickedToCancel(true);
    await scaffolderApi.cancelTask(taskId);
  };
  return /* @__PURE__ */ React.createElement(Page, { themeId: "home" }, /* @__PURE__ */ React.createElement(
    Header,
    {
      pageTitleOverride: `Task ${taskId}`,
      title: "Task Activity",
      subtitle: `Activity for task: ${taskId}`
    }
  ), /* @__PURE__ */ React.createElement(Content, null, taskNotFound ? /* @__PURE__ */ React.createElement(
    ErrorPage,
    {
      status: "404",
      statusMessage: "Task not found",
      additionalInfo: "No task found with this ID"
    }
  ) : /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement(Grid$1, { container: true }, /* @__PURE__ */ React.createElement(Grid$1, { item: true, xs: 3 }, /* @__PURE__ */ React.createElement(Paper, null, /* @__PURE__ */ React.createElement(
    TaskStatusStepper,
    {
      steps,
      currentStepId,
      onUserStepChange: setUserSelectedStepId
    }
  ), output && hasLinks(output) && /* @__PURE__ */ React.createElement(TaskPageLinks, { output }), /* @__PURE__ */ React.createElement(
    Button,
    {
      className: classes.button,
      onClick: handleStartOver,
      disabled: !completed,
      variant: "contained",
      color: "primary"
    },
    "Start Over"
  ), /* @__PURE__ */ React.createElement(
    Button,
    {
      className: classes.button,
      onClick: handleCancel,
      disabled: completed || taskCancelled || clickedToCancel,
      variant: "outlined",
      color: "secondary"
    },
    (taskCancelled || clickedToCancel) && !completed ? "Cancelling..." : "Cancel"
  ))), /* @__PURE__ */ React.createElement(Grid$1, { item: true, xs: 9 }, !currentStepId && /* @__PURE__ */ React.createElement(Progress, null), /* @__PURE__ */ React.createElement("div", { style: { height: "80vh" } }, /* @__PURE__ */ React.createElement(TaskErrors, { error: taskStream.error }), /* @__PURE__ */ React.createElement(LogViewer, { text: logAsString })))))));
};

export { TaskPage as T, TaskStatusStepper as a, TaskPageLinks as b };
//# sourceMappingURL=TaskPage-1a149db7.esm.js.map
