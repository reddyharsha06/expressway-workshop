import { scmIntegrationsApiRef, scmAuthApiRef } from '@backstage/integration-react';
import { scaffolderApiRef, useTemplateSecrets, createScaffolderFieldExtension } from '@backstage/plugin-scaffolder-react';
import { parseEntityRef, stringifyEntityRef, KubernetesValidatorFunctions, RELATION_OWNED_BY, makeValidator } from '@backstage/catalog-model';
import { ResponseError, NotFoundError } from '@backstage/errors';
import qs from 'qs';
import ObservableImpl from 'zen-observable';
import { EventSourcePolyfill } from 'event-source-polyfill';
import { CATALOG_FILTER_EXISTS } from '@backstage/catalog-client';
import { useApi, identityApiRef, createExternalRouteRef, createRouteRef, createSubRouteRef, errorApiRef, createPlugin, createApiFactory, discoveryApiRef, fetchApiRef, createRoutableExtension } from '@backstage/core-plugin-api';
import { catalogApiRef, humanizeEntityRef } from '@backstage/plugin-catalog-react';
import { TextField, FormControl as FormControl$1 } from '@material-ui/core';
import FormControl from '@material-ui/core/FormControl';
import Autocomplete from '@material-ui/lab/Autocomplete';
import React, { useCallback, useEffect, useState, useMemo } from 'react';
import useAsync from 'react-use/lib/useAsync';
import { z } from 'zod';
import zodToJsonSchema from 'zod-to-json-schema';
import FormHelperText from '@material-ui/core/FormHelperText';
import Input from '@material-ui/core/Input';
import InputLabel from '@material-ui/core/InputLabel';
import { Select, Progress } from '@backstage/core-components';
import useDebounce from 'react-use/lib/useDebounce';
import useEffectOnce from 'react-use/lib/useEffectOnce';
import { Autocomplete as Autocomplete$1 } from '@material-ui/lab';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class ScaffolderClient {
  constructor(options) {
    __publicField(this, "discoveryApi");
    __publicField(this, "scmIntegrationsApi");
    __publicField(this, "fetchApi");
    __publicField(this, "identityApi");
    __publicField(this, "useLongPollingLogs");
    var _a, _b;
    this.discoveryApi = options.discoveryApi;
    this.fetchApi = (_a = options.fetchApi) != null ? _a : { fetch };
    this.scmIntegrationsApi = options.scmIntegrationsApi;
    this.useLongPollingLogs = (_b = options.useLongPollingLogs) != null ? _b : false;
    this.identityApi = options.identityApi;
  }
  async listTasks(options) {
    if (!this.identityApi) {
      throw new Error(
        "IdentityApi is not available in the ScaffolderClient, please pass through the IdentityApi to the ScaffolderClient constructor in order to use the listTasks method"
      );
    }
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const { userEntityRef } = await this.identityApi.getBackstageIdentity();
    const query = qs.stringify(
      options.filterByOwnership === "owned" ? { createdBy: userEntityRef } : {}
    );
    const response = await this.fetchApi.fetch(`${baseUrl}/v2/tasks?${query}`);
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
  async getIntegrationsList(options) {
    const integrations = [
      ...this.scmIntegrationsApi.azure.list(),
      ...this.scmIntegrationsApi.bitbucket.list().filter(
        (item) => !this.scmIntegrationsApi.bitbucketCloud.byHost(item.config.host) && !this.scmIntegrationsApi.bitbucketServer.byHost(item.config.host)
      ),
      ...this.scmIntegrationsApi.bitbucketCloud.list(),
      ...this.scmIntegrationsApi.bitbucketServer.list(),
      ...this.scmIntegrationsApi.gerrit.list(),
      ...this.scmIntegrationsApi.github.list(),
      ...this.scmIntegrationsApi.gitlab.list()
    ].map((c) => ({ type: c.type, title: c.title, host: c.config.host })).filter((c) => options.allowedHosts.includes(c.host));
    return {
      integrations
    };
  }
  async getTemplateParameterSchema(templateRef) {
    const { namespace, kind, name } = parseEntityRef(templateRef, {
      defaultKind: "template"
    });
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const templatePath = [namespace, kind, name].map((s) => encodeURIComponent(s)).join("/");
    const url = `${baseUrl}/v2/templates/${templatePath}/parameter-schema`;
    const response = await this.fetchApi.fetch(url);
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    const schema = await response.json();
    return schema;
  }
  async scaffold(options) {
    const { templateRef, values, secrets = {} } = options;
    const url = `${await this.discoveryApi.getBaseUrl("scaffolder")}/v2/tasks`;
    const response = await this.fetchApi.fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        templateRef,
        values: { ...values },
        secrets
      })
    });
    if (response.status !== 201) {
      const status = `${response.status} ${response.statusText}`;
      const body = await response.text();
      throw new Error(`Backend request failed, ${status} ${body.trim()}`);
    }
    const { id } = await response.json();
    return { taskId: id };
  }
  async getTask(taskId) {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const url = `${baseUrl}/v2/tasks/${encodeURIComponent(taskId)}`;
    const response = await this.fetchApi.fetch(url);
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
  streamLogs(options) {
    if (this.useLongPollingLogs) {
      return this.streamLogsPolling(options);
    }
    return this.streamLogsEventStream(options);
  }
  async dryRun(options) {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const response = await this.fetchApi.fetch(`${baseUrl}/v2/dry-run`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        template: options.template,
        values: options.values,
        secrets: options.secrets,
        directoryContents: options.directoryContents
      })
    });
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return response.json();
  }
  streamLogsEventStream({
    taskId,
    after
  }) {
    return new ObservableImpl((subscriber) => {
      var _a;
      const params = new URLSearchParams();
      if (after !== void 0) {
        params.set("after", String(Number(after)));
      }
      Promise.all([
        this.discoveryApi.getBaseUrl("scaffolder"),
        (_a = this.identityApi) == null ? void 0 : _a.getCredentials()
      ]).then(
        ([baseUrl, credentials]) => {
          const url = `${baseUrl}/v2/tasks/${encodeURIComponent(
            taskId
          )}/eventstream`;
          const processEvent = (event) => {
            if (event.data) {
              try {
                subscriber.next(JSON.parse(event.data));
              } catch (ex) {
                subscriber.error(ex);
              }
            }
          };
          const eventSource = new EventSourcePolyfill(url, {
            withCredentials: true,
            headers: (credentials == null ? void 0 : credentials.token) ? { Authorization: `Bearer ${credentials.token}` } : {}
          });
          eventSource.addEventListener("log", processEvent);
          eventSource.addEventListener("cancelled", processEvent);
          eventSource.addEventListener("completion", (event) => {
            processEvent(event);
            eventSource.close();
            subscriber.complete();
          });
          eventSource.addEventListener("error", (event) => {
            subscriber.error(event);
          });
        },
        (error) => {
          subscriber.error(error);
        }
      );
    });
  }
  streamLogsPolling({
    taskId,
    after: inputAfter
  }) {
    let after = inputAfter;
    return new ObservableImpl((subscriber) => {
      this.discoveryApi.getBaseUrl("scaffolder").then(async (baseUrl) => {
        while (!subscriber.closed) {
          const url = `${baseUrl}/v2/tasks/${encodeURIComponent(
            taskId
          )}/events?${qs.stringify({ after })}`;
          const response = await this.fetchApi.fetch(url);
          if (!response.ok) {
            await new Promise((resolve) => setTimeout(resolve, 1e3));
            continue;
          }
          const logs = await response.json();
          for (const event of logs) {
            after = Number(event.id);
            subscriber.next(event);
            if (event.type === "completion") {
              subscriber.complete();
              return;
            }
          }
        }
      });
    });
  }
  async listActions() {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const response = await this.fetchApi.fetch(`${baseUrl}/v2/actions`);
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
  async cancelTask(taskId) {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const url = `${baseUrl}/v2/tasks/${encodeURIComponent(taskId)}/cancel`;
    const response = await this.fetchApi.fetch(url, {
      method: "POST"
    });
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
}

function makeFieldSchemaFromZod(returnSchema, uiOptionsSchema) {
  return {
    schema: {
      returnValue: zodToJsonSchema(returnSchema),
      uiOptions: uiOptionsSchema ? zodToJsonSchema(uiOptionsSchema) : void 0
    },
    type: null,
    uiOptionsType: null
  };
}

const entityQueryFilterExpressionSchema = z.record(
  z.string().or(z.object({ exists: z.boolean().optional() })).or(z.array(z.string()))
);
const EntityPickerFieldSchema = makeFieldSchemaFromZod(
  z.string(),
  z.object({
    /**
     * @deprecated Use `catalogFilter` instead.
     */
    allowedKinds: z.array(z.string()).optional().describe(
      "DEPRECATED: Use `catalogFilter` instead. List of kinds of entities to derive options from"
    ),
    defaultKind: z.string().optional().describe(
      "The default entity kind. Options of this kind will not be prefixed."
    ),
    allowArbitraryValues: z.boolean().optional().describe("Whether to allow arbitrary user input. Defaults to true"),
    defaultNamespace: z.union([z.string(), z.literal(false)]).optional().describe(
      "The default namespace. Options with this namespace will not be prefixed."
    ),
    catalogFilter: z.array(entityQueryFilterExpressionSchema).or(entityQueryFilterExpressionSchema).optional().describe("List of key-value filter expression for entities")
  })
);
const EntityPickerSchema = EntityPickerFieldSchema.schema;

const EntityPicker = (props) => {
  var _a, _b, _c, _d, _e;
  const {
    onChange,
    schema: { title = "Entity", description = "An entity from the catalog" },
    required,
    uiSchema,
    rawErrors,
    formData,
    idSchema
  } = props;
  const catalogFilter = buildCatalogFilter(uiSchema);
  const defaultKind = (_a = uiSchema["ui:options"]) == null ? void 0 : _a.defaultKind;
  const defaultNamespace = ((_b = uiSchema["ui:options"]) == null ? void 0 : _b.defaultNamespace) || void 0;
  const catalogApi = useApi(catalogApiRef);
  const { value: entities, loading } = useAsync(async () => {
    const { items } = await catalogApi.getEntities(
      catalogFilter ? { filter: catalogFilter } : void 0
    );
    return items;
  });
  const allowArbitraryValues = (_d = (_c = uiSchema["ui:options"]) == null ? void 0 : _c.allowArbitraryValues) != null ? _d : true;
  const getLabel = useCallback(
    (ref) => {
      try {
        return humanizeEntityRef(
          parseEntityRef(ref, { defaultKind, defaultNamespace }),
          {
            defaultKind,
            defaultNamespace
          }
        );
      } catch (err) {
        return ref;
      }
    },
    [defaultKind, defaultNamespace]
  );
  const onSelect = useCallback(
    (_, ref, reason) => {
      if (typeof ref !== "string") {
        onChange(ref ? stringifyEntityRef(ref) : void 0);
      } else {
        if (reason === "blur" || reason === "create-option") {
          let entityRef = ref;
          try {
            entityRef = stringifyEntityRef(
              parseEntityRef(ref, {
                defaultKind,
                defaultNamespace
              })
            );
          } catch (err) {
          }
          if (formData !== ref || allowArbitraryValues) {
            onChange(entityRef);
          }
        }
      }
    },
    [onChange, formData, defaultKind, defaultNamespace, allowArbitraryValues]
  );
  useEffect(() => {
    if ((entities == null ? void 0 : entities.length) === 1) {
      onChange(stringifyEntityRef(entities[0]));
    }
  }, [entities, onChange]);
  return /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !formData
    },
    /* @__PURE__ */ React.createElement(
      Autocomplete,
      {
        disabled: (entities == null ? void 0 : entities.length) === 1,
        id: idSchema == null ? void 0 : idSchema.$id,
        value: (
          // Since free solo can be enabled, attempt to parse as a full entity ref first, then fall
          //  back to the given value.
          (_e = entities == null ? void 0 : entities.find((e) => stringifyEntityRef(e) === formData)) != null ? _e : allowArbitraryValues && formData ? getLabel(formData) : ""
        ),
        loading,
        onChange: onSelect,
        options: entities || [],
        getOptionLabel: (option) => (
          // option can be a string due to freeSolo.
          typeof option === "string" ? option : humanizeEntityRef(option, { defaultKind, defaultNamespace })
        ),
        autoSelect: true,
        freeSolo: allowArbitraryValues,
        renderInput: (params) => /* @__PURE__ */ React.createElement(
          TextField,
          {
            ...params,
            label: title,
            margin: "dense",
            helperText: description,
            FormHelperTextProps: { margin: "dense", style: { marginLeft: 0 } },
            variant: "outlined",
            required,
            InputProps: params.InputProps
          }
        )
      }
    )
  );
};
function convertOpsValues(value) {
  if (typeof value === "object" && value.exists) {
    return CATALOG_FILTER_EXISTS;
  }
  return value == null ? void 0 : value.toString();
}
function convertSchemaFiltersToQuery(schemaFilters) {
  const query = {};
  for (const [key, value] of Object.entries(schemaFilters)) {
    if (Array.isArray(value)) {
      query[key] = value;
    } else {
      query[key] = convertOpsValues(value);
    }
  }
  return query;
}
function buildCatalogFilter(uiSchema) {
  var _a, _b;
  const allowedKinds = (_a = uiSchema["ui:options"]) == null ? void 0 : _a.allowedKinds;
  const catalogFilter = ((_b = uiSchema["ui:options"]) == null ? void 0 : _b.catalogFilter) || allowedKinds && { kind: allowedKinds };
  if (!catalogFilter) {
    return void 0;
  }
  if (Array.isArray(catalogFilter)) {
    return catalogFilter.map(convertSchemaFiltersToQuery);
  }
  return convertSchemaFiltersToQuery(catalogFilter);
}

const entityNamePickerValidation = (value, validation) => {
  if (!KubernetesValidatorFunctions.isValidObjectName(value)) {
    validation.addError(
      "Must start and end with an alphanumeric character, and contain only alphanumeric characters, hyphens, underscores, and periods. Maximum length is 63 characters."
    );
  }
};

const EntityNamePickerFieldSchema = makeFieldSchemaFromZod(z.string());
const EntityNamePickerSchema = EntityNamePickerFieldSchema.schema;

const EntityNamePicker = (props) => {
  const {
    onChange,
    required,
    schema: { title = "Name", description = "Unique name of the component" },
    rawErrors,
    formData,
    uiSchema: { "ui:autofocus": autoFocus },
    idSchema,
    placeholder
  } = props;
  return /* @__PURE__ */ React.createElement(
    TextField,
    {
      id: idSchema == null ? void 0 : idSchema.$id,
      label: title,
      placeholder,
      helperText: description,
      required,
      value: formData != null ? formData : "",
      onChange: ({ target: { value } }) => onChange(value),
      margin: "normal",
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !formData,
      inputProps: { autoFocus }
    }
  );
};

const OwnerPickerFieldSchema = makeFieldSchemaFromZod(
  z.string(),
  z.object({
    /**
     * @deprecated Use `catalogFilter` instead.
     */
    allowedKinds: z.array(z.string()).default(["Group", "User"]).optional().describe(
      "DEPRECATED: Use `catalogFilter` instead. List of kinds of entities to derive options from. Defaults to Group and User"
    ),
    allowArbitraryValues: z.boolean().optional().describe("Whether to allow arbitrary user input. Defaults to true"),
    defaultNamespace: z.union([z.string(), z.literal(false)]).optional().describe(
      "The default namespace. Options with this namespace will not be prefixed."
    ),
    catalogFilter: z.array(entityQueryFilterExpressionSchema).or(entityQueryFilterExpressionSchema).optional().describe("List of key-value filter expression for entities")
  })
);
const OwnerPickerSchema = OwnerPickerFieldSchema.schema;

const OwnerPicker = (props) => {
  var _a, _b, _c, _d, _e;
  const {
    schema: { title = "Owner", description = "The owner of the component" },
    uiSchema,
    ...restProps
  } = props;
  const defaultNamespace = (_a = uiSchema["ui:options"]) == null ? void 0 : _a.defaultNamespace;
  const allowedKinds = (_b = uiSchema["ui:options"]) == null ? void 0 : _b.allowedKinds;
  const catalogFilter = ((_c = uiSchema["ui:options"]) == null ? void 0 : _c.catalogFilter) || {
    kind: allowedKinds || ["Group", "User"]
  };
  const ownerUiSchema = {
    ...uiSchema,
    "ui:options": {
      catalogFilter,
      defaultKind: "Group",
      allowArbitraryValues: (_e = (_d = uiSchema["ui:options"]) == null ? void 0 : _d.allowArbitraryValues) != null ? _e : true,
      ...defaultNamespace !== void 0 ? { defaultNamespace } : {}
    }
  };
  return /* @__PURE__ */ React.createElement(
    EntityPicker,
    {
      ...restProps,
      schema: { title, description },
      uiSchema: ownerUiSchema
    }
  );
};

const RepoUrlPickerFieldSchema = makeFieldSchemaFromZod(
  z.string(),
  z.object({
    allowedHosts: z.array(z.string()).optional().describe("List of allowed SCM platform hosts"),
    allowedOrganizations: z.array(z.string()).optional().describe("List of allowed organizations in the given SCM platform"),
    allowedOwners: z.array(z.string()).optional().describe("List of allowed owners in the given SCM platform"),
    allowedProjects: z.array(z.string()).optional().describe("List of allowed projects in the given SCM platform"),
    allowedRepos: z.array(z.string()).optional().describe("List of allowed repos in the given SCM platform"),
    requestUserCredentials: z.object({
      secretsKey: z.string().describe(
        "Key used within the template secrets context to store the credential"
      ),
      additionalScopes: z.object({
        gerrit: z.array(z.string()).optional().describe("Additional Gerrit scopes to request"),
        github: z.array(z.string()).optional().describe("Additional GitHub scopes to request"),
        gitlab: z.array(z.string()).optional().describe("Additional GitLab scopes to request"),
        bitbucket: z.array(z.string()).optional().describe("Additional BitBucket scopes to request"),
        azure: z.array(z.string()).optional().describe("Additional Azure scopes to request")
      }).optional().describe("Additional permission scopes to request")
    }).optional().describe(
      "If defined will request user credentials to auth against the given SCM platform"
    )
  })
);
const RepoUrlPickerSchema = RepoUrlPickerFieldSchema.schema;

const repoPickerValidation = (value, validation, context) => {
  var _a, _b;
  try {
    const { host, searchParams } = new URL(`https://${value}`);
    const integrationApi = context.apiHolder.get(scmIntegrationsApiRef);
    if (!host) {
      validation.addError(
        "Incomplete repository location provided, host not provided"
      );
    } else {
      if (((_a = integrationApi == null ? void 0 : integrationApi.byHost(host)) == null ? void 0 : _a.type) === "bitbucket") {
        if (host === "bitbucket.org" && !searchParams.get("workspace")) {
          validation.addError(
            "Incomplete repository location provided, workspace not provided"
          );
        }
        if (!searchParams.get("project")) {
          validation.addError(
            "Incomplete repository location provided, project not provided"
          );
        }
      } else if (((_b = integrationApi == null ? void 0 : integrationApi.byHost(host)) == null ? void 0 : _b.type) !== "gerrit") {
        if (!searchParams.get("owner")) {
          validation.addError(
            "Incomplete repository location provided, owner not provided"
          );
        }
      }
      if (!searchParams.get("repo")) {
        validation.addError(
          "Incomplete repository location provided, repo not provided"
        );
      }
    }
  } catch {
    validation.addError("Unable to parse the Repository URL");
  }
};

const GithubRepoPicker = (props) => {
  const { allowedOwners = [], rawErrors, state, onChange } = props;
  const ownerItems = allowedOwners ? allowedOwners.map((i) => ({ label: i, value: i })) : [{ label: "Loading...", value: "loading" }];
  const { owner } = state;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !owner
    },
    (allowedOwners == null ? void 0 : allowedOwners.length) ? /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        label: "Owner Available",
        onChange: (s) => onChange({ owner: String(Array.isArray(s) ? s[0] : s) }),
        disabled: allowedOwners.length === 1,
        selected: owner,
        items: ownerItems
      }
    ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "ownerInput" }, "Owner"), /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "ownerInput",
        onChange: (e) => onChange({ owner: e.target.value }),
        value: owner
      }
    )),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The organization, user or project that this repo will belong to")
  ));
};

const GitlabRepoPicker = (props) => {
  const { allowedOwners = [], state, onChange, rawErrors } = props;
  const ownerItems = allowedOwners ? allowedOwners.map((i) => ({ label: i, value: i })) : [{ label: "Loading...", value: "loading" }];
  const { owner } = state;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !owner
    },
    (allowedOwners == null ? void 0 : allowedOwners.length) ? /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        label: "Owner Available",
        onChange: (selected) => onChange({
          owner: String(Array.isArray(selected) ? selected[0] : selected)
        }),
        disabled: allowedOwners.length === 1,
        selected: owner,
        items: ownerItems
      }
    ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "ownerInput" }, "Owner"), /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "ownerInput",
        onChange: (e) => onChange({ owner: e.target.value }),
        value: owner
      }
    )),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "GitLab namespace where this repository will belong to. It can be the name of organization, group, subgroup, user, or the project.")
  ));
};

const AzureRepoPicker = (props) => {
  const {
    allowedOrganizations = [],
    allowedOwners = [],
    rawErrors,
    state,
    onChange
  } = props;
  const organizationItems = allowedOrganizations ? allowedOrganizations.map((i) => ({ label: i, value: i })) : [{ label: "Loading...", value: "loading" }];
  const ownerItems = allowedOwners ? allowedOwners.map((i) => ({ label: i, value: i })) : [{ label: "Loading...", value: "loading" }];
  const { organization, owner } = state;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !organization
    },
    (allowedOrganizations == null ? void 0 : allowedOrganizations.length) ? /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        label: "Organization",
        onChange: (s) => onChange({ organization: String(Array.isArray(s) ? s[0] : s) }),
        disabled: allowedOrganizations.length === 1,
        selected: organization,
        items: organizationItems
      }
    ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "orgInput" }, "Organization"), /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "orgInput",
        onChange: (e) => onChange({ organization: e.target.value }),
        value: organization
      }
    )),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The Organization that this repo will belong to")
  ), /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !owner
    },
    (allowedOwners == null ? void 0 : allowedOwners.length) ? /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        label: "Owner",
        onChange: (s) => onChange({ owner: String(Array.isArray(s) ? s[0] : s) }),
        disabled: allowedOwners.length === 1,
        selected: owner,
        items: ownerItems
      }
    ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "ownerInput" }, "Project"), /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "ownerInput",
        onChange: (e) => onChange({ owner: e.target.value }),
        value: owner
      }
    )),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The Project that this repo will belong to")
  ));
};

const BitbucketRepoPicker = (props) => {
  const {
    allowedOwners = [],
    allowedProjects = [],
    onChange,
    rawErrors,
    state
  } = props;
  const { host, workspace, project } = state;
  const ownerItems = allowedOwners ? allowedOwners == null ? void 0 : allowedOwners.map((i) => ({ label: i, value: i })) : [];
  const projectItems = allowedProjects ? allowedProjects == null ? void 0 : allowedProjects.map((i) => ({ label: i, value: i })) : [];
  useEffect(() => {
    if (host === "bitbucket.org" && allowedOwners.length) {
      onChange({ workspace: allowedOwners[0] });
    }
  }, [allowedOwners, host, onChange]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, host === "bitbucket.org" && /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !workspace
    },
    (allowedOwners == null ? void 0 : allowedOwners.length) ? /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        label: "Allowed Workspaces",
        onChange: (s) => onChange({ workspace: String(Array.isArray(s) ? s[0] : s) }),
        disabled: allowedOwners.length === 1,
        selected: workspace,
        items: ownerItems
      }
    ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "workspaceInput" }, "Workspace"), /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "workspaceInput",
        onChange: (e) => onChange({ workspace: e.target.value }),
        value: workspace
      }
    )),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The Workspace that this repo will belong to")
  ), /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !project
    },
    (allowedProjects == null ? void 0 : allowedProjects.length) ? /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        label: "Allowed Projects",
        onChange: (s) => onChange({ project: String(Array.isArray(s) ? s[0] : s) }),
        disabled: allowedProjects.length === 1,
        selected: project,
        items: projectItems
      }
    ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "projectInput" }, "Project"), /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "projectInput",
        onChange: (e) => onChange({ project: e.target.value }),
        value: project
      }
    )),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The Project that this repo will belong to")
  ));
};

const GerritRepoPicker = (props) => {
  const { onChange, rawErrors, state } = props;
  const { workspace, owner } = state;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(FormControl, { margin: "normal", error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !workspace }, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "ownerInput" }, "Owner"), /* @__PURE__ */ React.createElement(
    Input,
    {
      id: "ownerInput",
      onChange: (e) => onChange({ owner: e.target.value }),
      value: owner
    }
  ), /* @__PURE__ */ React.createElement(FormHelperText, null, "The owner of the project (optional)")), /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !workspace
    },
    /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "parentInput" }, "Parent"),
    /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "parentInput",
        onChange: (e) => onChange({ workspace: e.target.value }),
        value: workspace
      }
    ),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The project parent that the repo will belong to")
  ));
};

const RepoUrlPickerHost = (props) => {
  const { host, hosts, onChange, rawErrors } = props;
  const scaffolderApi = useApi(scaffolderApiRef);
  const { value: { integrations } = { integrations: [] }, loading } = useAsync(
    async () => {
      return await scaffolderApi.getIntegrationsList({
        allowedHosts: hosts != null ? hosts : []
      });
    }
  );
  useEffect(() => {
    if (!host) {
      if (hosts == null ? void 0 : hosts.length) {
        onChange(hosts[0]);
      } else if (integrations == null ? void 0 : integrations.length) {
        onChange(integrations[0].host);
      }
    }
  }, [hosts, host, onChange, integrations]);
  const hostsOptions = integrations ? integrations.filter((i) => (hosts == null ? void 0 : hosts.length) ? hosts == null ? void 0 : hosts.includes(i.host) : true).map((i) => ({ label: i.title, value: i.host })) : [{ label: "Loading...", value: "loading" }];
  if (loading) {
    return /* @__PURE__ */ React.createElement(Progress, null);
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !host
    },
    /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        disabled: (hosts == null ? void 0 : hosts.length) === 1,
        label: "Host",
        onChange: (s) => onChange(String(Array.isArray(s) ? s[0] : s)),
        selected: host,
        items: hostsOptions,
        "data-testid": "host-select"
      }
    ),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The host where the repository will be created")
  ));
};

const RepoUrlPickerRepoName = (props) => {
  const { repoName, allowedRepos, onChange, rawErrors } = props;
  useEffect(() => {
    if (!repoName) {
      if (allowedRepos == null ? void 0 : allowedRepos.length) {
        onChange(allowedRepos[0]);
      }
    }
  }, [allowedRepos, repoName, onChange]);
  const repoItems = allowedRepos ? allowedRepos.map((i) => ({ label: i, value: i })) : [{ label: "Loading...", value: "loading" }];
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !repoName
    },
    (allowedRepos == null ? void 0 : allowedRepos.length) ? /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        label: "Repositories Available",
        onChange: (selected) => String(Array.isArray(selected) ? selected[0] : selected),
        disabled: allowedRepos.length === 1,
        selected: repoName,
        items: repoItems
      }
    ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "repoNameInput" }, "Repository"), /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "repoNameInput",
        onChange: (e) => onChange(String(e.target.value)),
        value: repoName
      }
    )),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The name of the repository")
  ));
};

function serializeRepoPickerUrl(data) {
  if (!data.host) {
    return void 0;
  }
  const params = new URLSearchParams();
  if (data.owner) {
    params.set("owner", data.owner);
  }
  if (data.repoName) {
    params.set("repo", data.repoName);
  }
  if (data.organization) {
    params.set("organization", data.organization);
  }
  if (data.workspace) {
    params.set("workspace", data.workspace);
  }
  if (data.project) {
    params.set("project", data.project);
  }
  return `${data.host}?${params.toString()}`;
}
function parseRepoPickerUrl(url) {
  let host = "";
  let owner = "";
  let repoName = "";
  let organization = "";
  let workspace = "";
  let project = "";
  try {
    if (url) {
      const parsed = new URL(`https://${url}`);
      host = parsed.host;
      owner = parsed.searchParams.get("owner") || "";
      repoName = parsed.searchParams.get("repo") || "";
      organization = parsed.searchParams.get("organization") || "";
      workspace = parsed.searchParams.get("workspace") || "";
      project = parsed.searchParams.get("project") || "";
    }
  } catch {
  }
  return { host, owner, repoName, organization, workspace, project };
}

const RepoUrlPicker = (props) => {
  var _a, _b;
  const { uiSchema, onChange, rawErrors, formData } = props;
  const [state, setState] = useState(
    parseRepoPickerUrl(formData)
  );
  const integrationApi = useApi(scmIntegrationsApiRef);
  const scmAuthApi = useApi(scmAuthApiRef);
  const { setSecrets } = useTemplateSecrets();
  const allowedHosts = useMemo(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) == null ? void 0 : _a2.allowedHosts) != null ? _b2 : [];
    },
    [uiSchema]
  );
  const allowedOrganizations = useMemo(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) == null ? void 0 : _a2.allowedOrganizations) != null ? _b2 : [];
    },
    [uiSchema]
  );
  const allowedOwners = useMemo(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) == null ? void 0 : _a2.allowedOwners) != null ? _b2 : [];
    },
    [uiSchema]
  );
  const allowedProjects = useMemo(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) == null ? void 0 : _a2.allowedProjects) != null ? _b2 : [];
    },
    [uiSchema]
  );
  const allowedRepos = useMemo(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) == null ? void 0 : _a2.allowedRepos) != null ? _b2 : [];
    },
    [uiSchema]
  );
  const { owner, organization, project, repoName } = state;
  useEffect(() => {
    onChange(serializeRepoPickerUrl(state));
  }, [state, onChange]);
  useEffect(() => {
    if (allowedOrganizations.length > 0 && !organization) {
      setState((prevState) => ({
        ...prevState,
        organization: allowedOrganizations[0]
      }));
    }
  }, [setState, allowedOrganizations, organization]);
  useEffect(() => {
    if (allowedOwners.length > 0 && !owner) {
      setState((prevState) => ({
        ...prevState,
        owner: allowedOwners[0]
      }));
    }
  }, [setState, allowedOwners, owner]);
  useEffect(() => {
    if (allowedProjects.length > 0 && !project) {
      setState((prevState) => ({
        ...prevState,
        project: allowedProjects[0]
      }));
    }
  }, [setState, allowedProjects, project]);
  useEffect(() => {
    if (allowedRepos.length > 0 && !repoName) {
      setState((prevState) => ({ ...prevState, repoName: allowedRepos[0] }));
    }
  }, [setState, allowedRepos, repoName]);
  const updateLocalState = useCallback(
    (newState) => {
      setState((prevState) => ({ ...prevState, ...newState }));
    },
    [setState]
  );
  useDebounce(
    async () => {
      var _a2;
      const { requestUserCredentials } = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) != null ? _a2 : {};
      const workspace = state.owner ? state.owner : state.project;
      if (!requestUserCredentials || !(state.host && workspace && state.repoName)) {
        return;
      }
      const [encodedHost, encodedRepoName] = [state.host, state.repoName].map(
        encodeURIComponent
      );
      const { token } = await scmAuthApi.getCredentials({
        url: `https://${encodedHost}/${workspace}/${encodedRepoName}`,
        additionalScope: {
          repoWrite: true,
          customScopes: requestUserCredentials.additionalScopes
        }
      });
      setSecrets({ [requestUserCredentials.secretsKey]: token });
    },
    500,
    [state, uiSchema]
  );
  const hostType = (_b = state.host && ((_a = integrationApi.byHost(state.host)) == null ? void 0 : _a.type)) != null ? _b : null;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    RepoUrlPickerHost,
    {
      host: state.host,
      hosts: allowedHosts,
      onChange: (host) => setState((prevState) => ({ ...prevState, host })),
      rawErrors
    }
  ), hostType === "github" && /* @__PURE__ */ React.createElement(
    GithubRepoPicker,
    {
      allowedOwners,
      onChange: updateLocalState,
      rawErrors,
      state
    }
  ), hostType === "gitlab" && /* @__PURE__ */ React.createElement(
    GitlabRepoPicker,
    {
      allowedOwners,
      rawErrors,
      state,
      onChange: updateLocalState
    }
  ), hostType === "bitbucket" && /* @__PURE__ */ React.createElement(
    BitbucketRepoPicker,
    {
      allowedOwners,
      allowedProjects,
      rawErrors,
      state,
      onChange: updateLocalState
    }
  ), hostType === "azure" && /* @__PURE__ */ React.createElement(
    AzureRepoPicker,
    {
      allowedOrganizations,
      allowedOwners,
      rawErrors,
      state,
      onChange: updateLocalState
    }
  ), hostType === "gerrit" && /* @__PURE__ */ React.createElement(
    GerritRepoPicker,
    {
      rawErrors,
      state,
      onChange: updateLocalState
    }
  ), /* @__PURE__ */ React.createElement(
    RepoUrlPickerRepoName,
    {
      repoName: state.repoName,
      allowedRepos,
      onChange: (repo) => setState((prevState) => ({ ...prevState, repoName: repo })),
      rawErrors
    }
  ));
};

const OwnedEntityPickerFieldSchema = makeFieldSchemaFromZod(
  z.string(),
  z.object({
    allowedKinds: z.array(z.string()).optional().describe("List of kinds of entities to derive options from"),
    defaultKind: z.string().optional().describe(
      "The default entity kind. Options of this kind will not be prefixed."
    ),
    allowArbitraryValues: z.boolean().optional().describe("Whether to allow arbitrary user input. Defaults to true"),
    defaultNamespace: z.union([z.string(), z.literal(false)]).optional().describe(
      "The default namespace. Options with this namespace will not be prefixed."
    )
  })
);
const OwnedEntityPickerSchema = OwnedEntityPickerFieldSchema.schema;

const OwnedEntityPicker = (props) => {
  var _a;
  const {
    schema: { title = "Entity", description = "An entity from the catalog" },
    uiSchema,
    required
  } = props;
  const identityApi = useApi(identityApiRef);
  const { loading, value: identityRefs } = useAsync(async () => {
    const identity = await identityApi.getBackstageIdentity();
    return identity.ownershipEntityRefs;
  });
  const allowedKinds = (_a = uiSchema["ui:options"]) == null ? void 0 : _a.allowedKinds;
  if (loading)
    return /* @__PURE__ */ React.createElement(
      Autocomplete,
      {
        loading,
        renderInput: (params) => /* @__PURE__ */ React.createElement(
          TextField,
          {
            ...params,
            label: title,
            margin: "dense",
            helperText: description,
            FormHelperTextProps: { margin: "dense", style: { marginLeft: 0 } },
            variant: "outlined",
            required,
            InputProps: params.InputProps
          }
        ),
        options: []
      }
    );
  return /* @__PURE__ */ React.createElement(
    EntityPicker,
    {
      ...props,
      schema: { title, description },
      allowedKinds,
      catalogFilter: allowedKinds ? {
        filter: {
          kind: allowedKinds,
          [`relations.${RELATION_OWNED_BY}`]: identityRefs || []
        }
      } : {
        filter: {
          [`relations.${RELATION_OWNED_BY}`]: identityRefs || []
        }
      }
    }
  );
};

const EntityTagsPickerFieldSchema = makeFieldSchemaFromZod(
  z.array(z.string()),
  z.object({
    kinds: z.array(z.string()).optional().describe("List of kinds of entities to derive tags from"),
    showCounts: z.boolean().optional().describe("Whether to show usage counts per tag"),
    helperText: z.string().optional().describe("Helper text to display")
  })
);
const EntityTagsPickerSchema = EntityTagsPickerFieldSchema.schema;

const EntityTagsPicker = (props) => {
  var _a, _b, _c;
  const { formData, onChange, uiSchema } = props;
  const catalogApi = useApi(catalogApiRef);
  const [tagOptions, setTagOptions] = useState([]);
  const [inputValue, setInputValue] = useState("");
  const [inputError, setInputError] = useState(false);
  const tagValidator = makeValidator().isValidTag;
  const kinds = (_a = uiSchema["ui:options"]) == null ? void 0 : _a.kinds;
  const showCounts = (_b = uiSchema["ui:options"]) == null ? void 0 : _b.showCounts;
  const helperText = (_c = uiSchema["ui:options"]) == null ? void 0 : _c.helperText;
  const { loading, value: existingTags } = useAsync(async () => {
    const facet = "metadata.tags";
    const tagsRequest = { facets: [facet] };
    if (kinds) {
      tagsRequest.filter = { kind: kinds };
    }
    const { facets } = await catalogApi.getEntityFacets(tagsRequest);
    const tagFacets = Object.fromEntries(
      facets[facet].map(({ value, count }) => [value, count])
    );
    setTagOptions(
      Object.keys(tagFacets).sort(
        (a, b) => showCounts ? tagFacets[b] - tagFacets[a] : a.localeCompare(b)
      )
    );
    return tagFacets;
  });
  const setTags = (_, values) => {
    let hasError = false;
    let addDuplicate = false;
    const currentTags = formData || [];
    if ((values == null ? void 0 : values.length) && currentTags.length < values.length) {
      const newTag = values[values.length - 1] = values[values.length - 1].toLocaleLowerCase("en-US").trim();
      hasError = !tagValidator(newTag);
      addDuplicate = currentTags.indexOf(newTag) !== -1;
    }
    setInputError(hasError);
    setInputValue(!hasError ? "" : inputValue);
    if (!hasError && !addDuplicate) {
      onChange(values || []);
    }
  };
  useEffectOnce(() => onChange(formData || []));
  return /* @__PURE__ */ React.createElement(FormControl$1, { margin: "normal" }, /* @__PURE__ */ React.createElement(
    Autocomplete$1,
    {
      multiple: true,
      freeSolo: true,
      filterSelectedOptions: true,
      onChange: setTags,
      value: formData || [],
      inputValue,
      loading,
      options: tagOptions,
      ChipProps: { size: "small" },
      renderOption: (option) => showCounts ? `${option} (${existingTags == null ? void 0 : existingTags[option]})` : option,
      renderInput: (params) => /* @__PURE__ */ React.createElement(
        TextField,
        {
          ...params,
          label: "Tags",
          onChange: (e) => setInputValue(e.target.value),
          error: inputError,
          helperText: helperText != null ? helperText : "Add any relevant tags, hit 'Enter' to add new tags. Valid format: [a-z0-9+#] separated by [-], at most 63 characters"
        }
      )
    }
  ));
};

const registerComponentRouteRef = createExternalRouteRef({
  id: "register-component",
  optional: true
});
const viewTechDocRouteRef = createExternalRouteRef({
  id: "view-techdoc",
  optional: true,
  params: ["namespace", "kind", "name"]
});
const rootRouteRef = createRouteRef({
  id: "scaffolder"
});
const legacySelectedTemplateRouteRef = createSubRouteRef({
  id: "scaffolder/legacy/selected-template",
  parent: rootRouteRef,
  path: "/templates/:templateName"
});
const selectedTemplateRouteRef = createSubRouteRef({
  id: "scaffolder/selected-template",
  parent: rootRouteRef,
  path: "/templates/:namespace/:templateName"
});
const scaffolderTaskRouteRef = createSubRouteRef({
  id: "scaffolder/task",
  parent: rootRouteRef,
  path: "/tasks/:taskId"
});
const scaffolderListTaskRouteRef = createSubRouteRef({
  id: "scaffolder/list-tasks",
  parent: rootRouteRef,
  path: "/tasks"
});
const actionsRouteRef = createSubRouteRef({
  id: "scaffolder/actions",
  parent: rootRouteRef,
  path: "/actions"
});
const editRouteRef = createSubRouteRef({
  id: "scaffolder/edit",
  parent: rootRouteRef,
  path: "/edit"
});

const MyGroupsPickerFieldSchema = makeFieldSchemaFromZod(
  z.string(),
  z.object({
    title: z.string().default("Group").describe("Group"),
    description: z.string().default("A group you are part of").describe("The group to which the entity belongs")
  })
);
const MyGroupsPickerSchema = MyGroupsPickerFieldSchema.schema;

const MyGroupsPicker = (props) => {
  const {
    schema: { title, description },
    required,
    rawErrors,
    onChange
  } = props;
  const identityApi = useApi(identityApiRef);
  const catalogApi = useApi(catalogApiRef);
  const errorApi = useApi(errorApiRef);
  const [groups, setGroups] = useState([]);
  const [selectedGroup, setSelectedGroup] = useState(null);
  useAsync(async () => {
    const { userEntityRef } = await identityApi.getBackstageIdentity();
    if (!userEntityRef) {
      errorApi.post(new NotFoundError("No user entity ref found"));
      return;
    }
    const { items } = await catalogApi.getEntities({
      filter: {
        kind: "Group",
        ["relations.hasMember"]: [userEntityRef]
      }
    });
    const groupValues = items.filter((e) => Boolean(e)).map((item) => {
      var _a;
      return {
        label: (_a = item.metadata.title) != null ? _a : item.metadata.name,
        ref: stringifyEntityRef(item)
      };
    });
    setGroups(groupValues);
  });
  const updateChange = (_, value) => {
    var _a;
    setSelectedGroup(value);
    onChange((_a = value == null ? void 0 : value.ref) != null ? _a : "");
  };
  return /* @__PURE__ */ React.createElement(
    FormControl$1,
    {
      margin: "normal",
      required,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0
    },
    /* @__PURE__ */ React.createElement(
      Autocomplete$1,
      {
        id: "OwnershipEntityRefPicker-dropdown",
        options: groups || [],
        value: selectedGroup,
        onChange: updateChange,
        getOptionLabel: (group) => group.label,
        renderInput: (params) => /* @__PURE__ */ React.createElement(
          TextField,
          {
            ...params,
            label: title,
            margin: "dense",
            helperText: description,
            FormHelperTextProps: { margin: "dense", style: { marginLeft: 0 } },
            variant: "outlined",
            required
          }
        )
      }
    )
  );
};

const scaffolderPlugin = createPlugin({
  id: "scaffolder",
  apis: [
    createApiFactory({
      api: scaffolderApiRef,
      deps: {
        discoveryApi: discoveryApiRef,
        scmIntegrationsApi: scmIntegrationsApiRef,
        fetchApi: fetchApiRef,
        identityApi: identityApiRef
      },
      factory: ({ discoveryApi, scmIntegrationsApi, fetchApi, identityApi }) => new ScaffolderClient({
        discoveryApi,
        scmIntegrationsApi,
        fetchApi,
        identityApi
      })
    })
  ],
  routes: {
    root: rootRouteRef,
    selectedTemplate: selectedTemplateRouteRef,
    ongoingTask: scaffolderTaskRouteRef,
    actions: actionsRouteRef,
    listTasks: scaffolderListTaskRouteRef,
    edit: editRouteRef
  },
  externalRoutes: {
    registerComponent: registerComponentRouteRef,
    viewTechDoc: viewTechDocRouteRef
  }
});
const EntityPickerFieldExtension = scaffolderPlugin.provide(
  createScaffolderFieldExtension({
    component: EntityPicker,
    name: "EntityPicker",
    schema: EntityPickerSchema
  })
);
const EntityNamePickerFieldExtension = scaffolderPlugin.provide(
  createScaffolderFieldExtension({
    component: EntityNamePicker,
    name: "EntityNamePicker",
    validation: entityNamePickerValidation,
    schema: EntityNamePickerSchema
  })
);
const RepoUrlPickerFieldExtension = scaffolderPlugin.provide(
  createScaffolderFieldExtension({
    component: RepoUrlPicker,
    name: "RepoUrlPicker",
    validation: repoPickerValidation,
    schema: RepoUrlPickerSchema
  })
);
const OwnerPickerFieldExtension = scaffolderPlugin.provide(
  createScaffolderFieldExtension({
    component: OwnerPicker,
    name: "OwnerPicker",
    schema: OwnerPickerSchema
  })
);
const MyGroupsPickerFieldExtension = scaffolderPlugin.provide(
  createScaffolderFieldExtension({
    component: MyGroupsPicker,
    name: "MyGroupsPicker",
    schema: MyGroupsPickerSchema
  })
);
const ScaffolderPage = scaffolderPlugin.provide(
  createRoutableExtension({
    name: "ScaffolderPage",
    component: () => import('./Router-8c688e9d.esm.js').then((m) => m.Router),
    mountPoint: rootRouteRef
  })
);
const OwnedEntityPickerFieldExtension = scaffolderPlugin.provide(
  createScaffolderFieldExtension({
    component: OwnedEntityPicker,
    name: "OwnedEntityPicker",
    schema: OwnedEntityPickerSchema
  })
);
const EntityTagsPickerFieldExtension = scaffolderPlugin.provide(
  createScaffolderFieldExtension({
    component: EntityTagsPicker,
    name: "EntityTagsPicker",
    schema: EntityTagsPickerSchema
  })
);
const NextScaffolderPage = scaffolderPlugin.provide(
  createRoutableExtension({
    name: "NextScaffolderPage",
    component: () => import('./index-2bd1afcd.esm.js').then((m) => m.Router),
    mountPoint: rootRouteRef
  })
);

export { entityNamePickerValidation as A, EntityNamePickerSchema as B, EntityTagsPicker as C, EntityTagsPickerSchema as D, EntityPickerFieldExtension as E, RepoUrlPicker as F, RepoUrlPickerSchema as G, OwnerPicker as H, OwnerPickerSchema as I, OwnedEntityPicker as J, OwnedEntityPickerSchema as K, MyGroupsPicker as L, MyGroupsPickerFieldExtension as M, NextScaffolderPage as N, OwnerPickerFieldExtension as O, RepoUrlPickerFieldExtension as R, ScaffolderClient as S, EntityNamePickerFieldExtension as a, EntityTagsPickerFieldExtension as b, OwnedEntityPickerFieldExtension as c, ScaffolderPage as d, EntityPickerFieldSchema as e, OwnerPickerFieldSchema as f, RepoUrlPickerFieldSchema as g, repoPickerValidation as h, OwnedEntityPickerFieldSchema as i, EntityTagsPickerFieldSchema as j, MyGroupsPickerSchema as k, MyGroupsPickerFieldSchema as l, makeFieldSchemaFromZod as m, selectedTemplateRouteRef as n, scaffolderTaskRouteRef as o, editRouteRef as p, actionsRouteRef as q, rootRouteRef as r, scaffolderPlugin as s, scaffolderListTaskRouteRef as t, registerComponentRouteRef as u, viewTechDocRouteRef as v, legacySelectedTemplateRouteRef as w, EntityPicker as x, EntityPickerSchema as y, EntityNamePicker as z };
//# sourceMappingURL=plugin-34a96253.esm.js.map
